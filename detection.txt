// Start with the most specific indicator - calc.exe process
#event_simpleName=ProcessRollup2 
| filter FileName="calc.exe" AS calc_process

// Join to find PowerShell parent processes
| join inner 
  (
    #event_simpleName=ProcessRollup2 
    | filter FileName IN ("powershell.exe", "pwsh.exe") AS ps_parent
  ) on calc_process.ParentProcessId = ps_parent.ProcessId within=10s

// Focus on PowerShell processes with specific command patterns
| filter (
    // Look for specific function names instead of wildcards
    (ps_parent.CommandLine contains "GetEncryptionKey" OR 
     ps_parent.CommandLine contains "Encrypt-Bytes" OR 
     ps_parent.CommandLine contains "Decrypt-Bytes") AND
    
    // Look for specific memory manipulation techniques
    (ps_parent.CommandLine contains "SecureStringToBSTR" OR 
     ps_parent.CommandLine contains "PtrToStringAuto") AND
    
    // Look for assembly loading patterns
    (ps_parent.CommandLine contains "Assembly.Load" OR 
     ps_parent.CommandLine contains "GetMethod")
) AS ps_parent

// Join to find binary creation on desktop - specific path components instead of wildcards
| join inner
  (
    #event_simpleName=FileWritten 
    | filter TargetFileName contains "Desktop" AND 
             TargetFileName contains "thundr_" AND 
             (TargetFileName endsWith ".bin" OR TargetFileName endsWith ".dll")
    AS desktop_file
  ) on ps_parent.ProcessId = desktop_file.ProcessId within=5m

// Join to find temporary DLL creation-deletion pattern
| join inner
  (
    #event_simpleName=FileWritten
    | filter TargetFileName contains "Temp" AND 
             TargetFileName endsWith ".dll" AS temp_dll_created
    | join inner
      (
        #event_simpleName=FileDeleted
        | filter TargetFileName contains "Temp" AND 
                 TargetFileName endsWith ".dll" AS temp_dll_deleted
      ) on ProcessId, TargetFileName within=30s
  ) on ps_parent.ProcessId = temp_dll_created.ProcessId within=5m

// Join to find specific cryptographic API usage
| join inner
  (
    #event_simpleName=ModuleLoad 
    | filter (ModuleFileName contains "System.Security.Cryptography" OR
              ModuleFileName contains "Reflection")
    AS crypto_module
  ) on ps_parent.ContextProcessId = crypto_module.ContextProcessId within=5m

// Join to detect memory allocation for executable content
| join inner
  (
    #event_simpleName=MemoryAllocationSubmitted
    | filter Protect=0x40 // PAGE_EXECUTE_READWRITE
    AS mem_alloc
  ) on ps_parent.ContextProcessId = mem_alloc.ContextProcessId within=5m

// Group by computer and timestamp to reduce result set size
| groupBy([ps_parent.ComputerName, format_time(calc_process._time, "yyyy-MM-dd HH")])
  {
    // Collect only the most critical fields
    collect([
      calc_process.ProcessId,
      ps_parent.ProcessId,
      ps_parent.CommandLine,
      desktop_file.TargetFileName,
      temp_dll_created.TargetFileName,
      mem_alloc.AllocationBase
    ]) as DetectionDetails
    
    // Track first occurrence time
    min(calc_process._time) as FirstSeen
    
    // Track count for volume analysis
    count() as EventCount
  } AS detection_group

// Add detection context
| eval TechniqueName = "Hostname-Encrypted DLL with Calculator Execution"
| eval Description = "PowerShell creating encrypted DLL using hostname as key, launching calculator process with potential P/Invoke console hiding"

// Format output
| sort by FirstSeen asc
| project 
    ComputerName,
    FirstSeen, 
    EventCount,
    TechniqueName,
    Description,
    DetectionDetails